var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [ComponentArrays]","category":"page"},{"location":"api/#ComponentArrays.Axis","page":"API","title":"ComponentArrays.Axis","text":"ax = Axis(nt::NamedTuple)\n\nGives named component access for ComponentArrays.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis((a = 1, b = ViewAxis(2:7, PartitionedAxis(2, (a = 1, b = 2))), c = ViewAxis(8:10, (a = 1, b = 2:3))));\n\njulia> A = [100, 4, 1.3, 1, 1, 4.4, 0.4, 2, 1, 45];\n\njulia> ca = ComponentArray(A, ax)\nComponentArray{Float64}(a = 100.0, b = [(a = 4.0, b = 1.3), (a = 1.0, b = 1.0), (a = 4.4, b = 0.4)], c = (a = 2.0, b = [1.0, 45.0]))\n\njulia> ca.a\n100.0\n\njulia> ca.b\n3-element Array{ComponentArray{Float64,1,SubArray{Float64,1,Array{Float64,1},Tuple{UnitRange{Int64}},true},Tuple{Axis{(a = 1, b = 2)}}},1}:\n (a = 4.0, b = 1.3)\n (a = 1.0, b = 1.0)\n (a = 4.4, b = 0.4)\n\njulia> ca.c\nComponentArray{SubArray{Float64,1,Array{Float64,1},Tuple{UnitRange{Int64}},true}}(a = 2.0, b = [1.0, 45.0])\n\njulia> ca.c.b\n2-element view(::Array{Float64,1}, 9:10) with eltype Float64:\n  1.0\n 45.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentArray","page":"API","title":"ComponentArrays.ComponentArray","text":"x = ComponentArray(nt::NamedTuple)\nx = ComponentArray(;kwargs...)\nx = ComponentArray(data::AbstractVector, ax)\nx = ComponentArray{T}(args...; kwargs...) where T\n\nArray type that can be accessed like an arbitrary nested mutable struct.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> x = ComponentArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> x.c.a = 400; x\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n\njulia> x[5]\n400.0\n\njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentMatrix","page":"API","title":"ComponentArrays.ComponentMatrix","text":"x = ComponentMatrix(data::AbstractMatrix, ax...)\nx = ComponentMatrix{T}(data::AbstractMatrix, ax...) where T\n\nA ComponentMatrix is an alias for a two-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ComponentVector","page":"API","title":"ComponentArrays.ComponentVector","text":"x = ComponentVector(nt::NamedTuple)\nx = ComponentVector(;kwargs...)\nx = ComponentVector(data::AbstractVector, ax)\nx = ComponentVector{T}(args...; kwargs...) where T\n\nA ComponentVector is an alias for a one-dimensional ComponentArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.PartitionedAxis","page":"API","title":"ComponentArrays.PartitionedAxis","text":"pa = PartitionedAxis(partition_size, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ShapedAxis","page":"API","title":"ComponentArrays.ShapedAxis","text":"sa = ShapedAxis(shape, index_map)\n\nPreserves higher-dimensional array components in ComponentArrays (matrix components, for example)\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.ViewAxis","page":"API","title":"ComponentArrays.ViewAxis","text":"va = ViewAxis(parent_index, index_map)\n\nAxis for creating arrays of ComponentArrays\n\n\n\n\n\n","category":"type"},{"location":"api/#ComponentArrays.fastindices-Tuple","page":"API","title":"ComponentArrays.fastindices","text":"fastindices(i...)\n\nWrap ComponentArray symbolic indices in Vals for type-stable indexing.\n\nExamples\n\njulia> using ComponentArrays, BenchmarkTools\n\njulia> ca = ComponentArray(a=1, b=[2, 1, 4], c=(a=2, b=[1, 2]))\nComponentArray{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n\njulia> ca2 = ca .* ca'\n7×7 ComponentArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = \n2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n\njulia> _a, _b, _c = fastindices(:a, :b, :c)\n(Val{:a}(), Val{:b}(), Val{:c}())\n\njulia> @btime $ca2[:c,:c];\n  12.199 μs (2 allocations: 80 bytes)\n\njulia> @btime $ca2[$_c, $_c];\n  14.728 ns (2 allocations: 80 bytes)\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getaxes-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getaxes","text":"getaxes(x::ComponentArray)\n\nAccess .axes field of a ComponentArray. This is different than axes(x::ComponentArray), which     returns the axes of the contained array.\n\nExamples\n\njulia> using ComponentArrays\n\njulia> ax = Axis(a=1:3, b=(4:6, (a=1, b=2:3)))\nAxis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}()\n\njulia> A = zeros(6,6);\n\njulia> ca = ComponentArray(A, (ax, ax))\n6×6 ComponentArray{Tuple{Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))},Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0  0.0\n\njulia> getaxes(ca)\n(Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}(), Axis{(a = 1:3, b = (4:6, (a = 1, b = 2:3)))}())\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.getdata-Tuple{ComponentArray}","page":"API","title":"ComponentArrays.getdata","text":"getdata(x::ComponentArray)\n\nAccess .data field of a ComponentArray, which contains the array that ComponentArray wraps.\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.label2index-Tuple{ComponentArray{T,1,A,Axes} where Axes where A where T,AbstractString}","page":"API","title":"ComponentArrays.label2index","text":"label2index(x::ComponentVector, str::AbstractString)\nlabel2index(label_array, str::AbstractString)\n\nConvert labels made by labels function to an array of flat indices of a ComponentVector.\n\nExamples\n\njulia> x = ComponentArray(a=5, b=[(a=(a=20,b=1), b=0), (a=(a=33,b=1), b=0)], c=(a=(a=2, b=[1,2]), b=[1. 2.; 5 6]))\nComponentVector{Float64}(a = 5.0, b = [(a = (a = 20.0, b = 1.0), b = 0.0), (a = (a = 33.0, b = 1.0), b = 0.0)], c = (a = (a = 2.0, b = [1.0, 2.0]), b = [1.0 2.0; 5.0 6.0]))\n\njulia> labels(x)\n14-element Array{String,1}:\n \"a\"\n \"b[1].a.a\"\n \"b[1].a.b\"\n \"b[1].b\"\n \"b[2].a.a\"\n \"b[2].a.b\"\n \"b[2].b\"\n \"c.a.a\"\n \"c.a.b[1]\"\n \"c.a.b[2]\"\n \"c.b[1,1]\"\n \"c.b[2,1]\"\n \"c.b[1,2]\"\n \"c.b[2,2]\"\n\njulia> label2index(x, \"c.a\")\n3-element Array{Int64,1}:\n  8\n  9\n 10\n\njulia> label2index(x, \"b[1]\")\n3-element Array{Int64,1}:\n 2\n 3\n 4\n\nsee also labels\n\n\n\n\n\n","category":"method"},{"location":"api/#ComponentArrays.labels-Tuple{ComponentArray{T,1,A,Axes} where Axes where A where T}","page":"API","title":"ComponentArrays.labels","text":"labels(x::ComponentVector)\n\nGet string labels for for each index of a ComponentVector. Useful for automatic plot legend labelling.\n\nExamples\n\njulia> x = ComponentArray(a=5, b=[(a=(a=20,b=1), b=0), (a=(a=33,b=1), b=0)], c=(a=(a=2, b=[1,2]), b=[1. 2.; 5 6]))\nComponentVector{Float64}(a = 5.0, b = [(a = (a = 20.0, b = 1.0), b = 0.0), (a = (a = 33.0, b = 1.0), b = 0.0)], c = (a = (a = 2.0, b = [1.0, 2.0]), b = [1.0 2.0; 5.0 6.0]))\n\njulia> labels(x)\n14-element Array{String,1}:\n \"a\"\n \"b[1].a.a\"\n \"b[1].a.b\"\n \"b[1].b\"\n \"b[2].a.a\"\n \"b[2].a.b\"\n \"b[2].b\"\n \"c.a.a\"\n \"c.a.b[1]\"\n \"c.a.b[2]\"\n \"c.b[1,1]\"\n \"c.b[2,1]\"\n \"c.b[1,2]\"\n \"c.b[2,2]\"\n\nsee also label2index\n\n\n\n\n\n","category":"method"},{"location":"examples/adaptive_control/#Model-Reference-Adaptive-Control-1","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"","category":"section"},{"location":"examples/adaptive_control/#Motivation-1","page":"Model Reference Adaptive Control","title":"Motivation","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Adaptive control is a good example of the type of problem that would be difficult to handle in a differential equations library without some sort of component system. We'll see how easy ComponentArrays make it to swap out subsystems, even when they have a different number of internal states.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"This specific example will walk through a typical adaptive control problem with online parameter estimation. For offline parameter estimation, check out the DifferentialEquations.jl docs.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"using ComponentArrays\nusing ControlSystems\nusing DifferentialEquations\nusing UnPack\nusing Plots","category":"page"},{"location":"examples/adaptive_control/#Helper-Functions-1","page":"Model Reference Adaptive Control","title":"Helper Functions","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"These helper functions will eventually make it into a separate package aimed at simulating control systems problems. The idea is to make it easier to bring linear models from ControlSystems.jl into nonlinear simulations in DifferentialEquations.jl. For now, we'll just define everything we need here.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"First, we need a way to apply inputs to the system through keyword arguments. These will help us pass in inputs as either values or functions of (x,p,t).","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"maybe_apply(f::Function, x, p, t) = f(x, p, t)\nmaybe_apply(f, x, p, t) = f\n\nfunction apply_inputs(func; kwargs...)\n    simfun(dx, x, p, t) = func(dx, x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    simfun(x, p, t) = func(x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    return simfun\nend\n","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Next, we need a way to create derivative functions from transfer functions. In ControlSystems.jl there is a function called simulator that does this, but the inputs must be applied from the start so we couldn't use it as a component function. Our version allows inputs to be passed through the keyword arguments and, as an added convenience, is in a transposed observer canonical form so our first element of x is also the output y (note that while this is true for our problem, it isn't always going to be the case).","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"SISO_simulator(P::TransferFunction) = SISO_simulator(ss(P))\nfunction SISO_simulator(P::AbstractStateSpace)\n    @unpack A, B, C, D = P\n\n    if size(D)!=(1,1)\n        error(\"This is not a SISO system\")\n    end\n\n    # Put into transposed observer canonical form so the first element is also the y value\n    BB = reverse(vec(C))\n    CC = reverse(vec(B))'\n    DD = D[1,1]\n    \n    return function sim!(dx, x, p, t; u=0.0)\n        dx .= A*x + BB*u\n        return CC*x + DD*u\n    end\nend","category":"page"},{"location":"examples/adaptive_control/#Laplace-Domain-Model-Specification-1","page":"Model Reference Adaptive Control","title":"Laplace Domain Model Specification","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Using ControlSystems.jl we'll make a Laplace variable s.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"s = tf(\"s\")","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We can build a reference model in the Laplace domain","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"am = 3\nbm = 3\nref_model = bm / (s + am)\nref_sim! = SISO_simulator(ref_model)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"and our plant model as well. The nominal plant model structure is what is known to our adaptation law.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"ap = 1\nbp = 2\nnominal_plant = bp / (s + ap)\nnominal_sim! = SISO_simulator(nominal_plant)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"To test robustness to uncertainty, we'll also include unmodeled dynamics with an entirely different structure than our nominal plant model.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"unmodeled_dynamics = 229/(s^2 + 30s + 229)\ntruth_plant = nominal_plant * unmodeled_dynamics\ntruth_sim! = SISO_simulator(truth_plant)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Let's do a quick sanity check to make sure our nominal and truth plant dynamics are about the same. We'll use the apply_inputs function to plot a step response and a sine response.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"step_p = plot(solve(ODEProblem(apply_inputs(truth_sim!; u=1), truth_ic, (0.0, 10.0))); vars=1, label=\"truth model\")\nplot!(step_p, solve(ODEProblem(apply_inputs(nominal_sim!; u=1), nominal_ic, (0.0, 10.0))); vars=1, label=\"nominal model\")\n\nu = (x,p,t) -> sin(3t)\nsin_p = plot(solve(ODEProblem(apply_inputs(truth_sim!; u=u), truth_ic, (0.0, 10.0))); vars=1, label=\"truth model\")\nplot!(sin_p, solve(ODEProblem(apply_inputs(nominal_sim!; u=u), nominal_ic, (0.0, 10.0))); vars=1, label=\"nominal model\")\n\nplot(step_p, sin_p; layout=(2,1), size=(800, 800))","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We'll make a first-order sensor as well so we can add noise to our measurement.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"τ = 0.005\nsensor_plant = 1 / (τ*s + 1)\nsensor_sim! = SISO_simulator(sensor_plant)","category":"page"},{"location":"examples/adaptive_control/#Derivative-Functions-1","page":"Model Reference Adaptive Control","title":"Derivative Functions","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Our control law assumes perfect knowledge of the parameters that are attached to the regressors (which are the reference input and the model output)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"control(θ, w) = θ'w","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"We'll use a simple gradient descent adaptation law","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function adapt!(Dθ, θ, γ, t; e, w)\n    Dθ .= -γ*e*w\n    return nothing\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Our feedback loop takes in the reference model output ym and the input signal r, calculates the control signal u, feeds that into the plant model, calculates the reference tracking error e, and finally updates feeds the reference tracking error and it's corresponding regressor vector to the adaptation law.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function feedback_sys!(D, vars, p, t; ym, r, n)\n    @unpack parameter_estimates, plant_model, sensor = vars\n    γ = p.gamma\n    regressor = [r, plant_model[1]]\n\n    u = control(parameter_estimates, regressor)\n    yp = p.plant_fun(D.plant_model, plant_model, (), t; u=u)\n    ŷ = sensor_sim!(D.sensor, sensor, (), t; u=yp[1]) + n\n    e = ŷ .- ym\n    regressor[2] = ŷ\n    adapt!(D.parameter_estimates, parameter_estimates, γ, t; e=e, w=regressor)\n    return yp\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Now the full system takes in an input signal r, feeds it through the reference model, and feeds the output of the reference model ym and the input signal to feedback_sys.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function system!(D, vars, p, t; r=0.0, n=0.0)\n    @unpack reference_model, feedback_loop = vars\n\n    ym = ref_sim!(D.reference_model, reference_model, (), t; u=r)\n    yp = feedback_sys!(D.feedback_loop, feedback_loop, p, t; ym=ym, r=r, n=n)\n    return yp\nend","category":"page"},{"location":"examples/adaptive_control/#Simulation-Inputs-1","page":"Model Reference Adaptive Control","title":"Simulation Inputs","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"# Simulation time span\ntspan = (0.0, 30.0)\n\n# Input signal\ninput_signal = (x,p,t) -> sin(3t)\n\n# Initial conditions\nref_ic = zeros(1)\nnominal_ic = zeros(1)\ntruth_ic = zeros(3)\nsensor_ic = zeros(1)\nθ_est_ic = ComponentArray(θr=0.0, θy=0.0)","category":"page"},{"location":"examples/adaptive_control/#Set-Up-Simulation-1","page":"Model Reference Adaptive Control","title":"Set Up Simulation","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"function simulate(plant_fun, plant_ic;\n                tspan=tspan,\n                input_signal=input_signal,\n                adapt_gain=1.5,\n                noise_param=nothing,\n                deterministic_noise=0.0)\n\n    noise(D, vars, p, t) = (D.feedback_loop.sensor[1] = noise_param)\n\n    # Truth control parameters\n    θ_truth = (r=bm/bp, y=(ap-am)/bp)\n\n    # Initial conditions\n    ic = ComponentArray(\n        reference_model = ref_ic,\n        feedback_loop = (\n            parameter_estimates = θ_est_ic,\n            sensor = sensor_ic,\n            plant_model = plant_ic,\n        ),\n    )\n\n    # Model parameters\n    p = (\n        gamma = adapt_gain,\n        plant_fun = plant_fun,\n    )\n\n    sim_fun = apply_inputs(system!; r=input_signal, n=deterministic_noise)\n\n    # We can also choose whether we want to include random noise in our model by switching between an ODE\n    # and an SDE problem.\n    if noise_param === nothing\n        prob = ODEProblem(sim_fun, ic, tspan, p, max_iters=2000)\n    else\n        prob = SDEProblem(sim_fun, noise, ic, tspan, p, max_iters=2000)\n    end\n\n\n    ## Solve!\n    sol = solve(prob)\n\n\n    ## Plot\n    # Reference model tracking\n    top = plot(\n        sol,\n        vars=[\"reference_model[1]\", \"feedback_loop.sensor\"],\n        legend=:right,\n        title=\"Reference Model Tracking\",\n    )\n\n    # Parameter estimate tracking\n    bottom = plot(sol, vars=\"feedback_loop.parameter_estimates\")\n    plot!(\n        bottom,\n        [tspan...], [θ_truth.r θ_truth.y; θ_truth.r θ_truth.y],\n        labels=[\"θr truth\" \"θy truth\"],\n        legend=:right,\n        title=\"Parameter Estimate Tracking\",\n    )\n\n    # Combine both plots\n    plot(top, bottom, layout=(2,1), size=(800, 800))\nend","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"And now let's run the simulation and plot.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(nominal_sim!, nominal_ic; noise_param=0.2)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#Unmodeled-Dynamics-1","page":"Model Reference Adaptive Control","title":"Unmodeled Dynamics","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Notice our parameter estimates are converging to a slightly different number than the truth values. This is because we didn't take the sensor dynamics into account in our adaptation law. Thankfully we are pretty robust to this. Let's push it a little further though. Remember our truth plant model with the extra unmodelled dynamics? Let's plot that one up now. Notice how easy it ComponentArrays make it to switch out the two simulations, despite the fact that the two plant models have a different number of states. ","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(truth_sim!, truth_ic; noise_param=0.2)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Even though our parameters aren't tracking what we think they should be, we are still tracking our reference model well. In real systems, there are always going to be unaccounted-for dynamics, so it's important that we are robust to that.","category":"page"},{"location":"examples/adaptive_control/#Insufficient-Excitation-and-Rohr's-Example-1","page":"Model Reference Adaptive Control","title":"Insufficient Excitation and Rohr's Example","text":"","category":"section"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Readers familiar with adaptive control might have noticed that our plant model parameters weren't just arbitrarily chosen; they come from Rohr's well-known example of parameter drift for insufficient excitation. To see this in action, let's look at what happens when we feed our model a stationary input. We'll switch to the same purely deterministic noise model that Rohr used. The parameter adaptation gain is a best guess to match the original data.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(nominal_sim!, nominal_ic;\n        input_signal = 2.0,\n        deterministic_noise = (x,p,t) -> 0.5sin(16.1t),\n        noise_param = nothing,\n        tspan = (0.0, 100.0),\n        adapt_gain = 3.35)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Interesting. If we were just looking at the model reference tracking, it would seem that everything is okay. The parameters are drifting within a space that keeps the reference tracking error small. This is pretty typical for \"insufficiently excited\" systems, i.e. systems whose input is either flat or at frequencies that are attenuated by the plant dynamics. Now let's see what happens with our truth model.","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"simulate(truth_sim!, truth_ic;\n           input_signal = 2.0,\n           deterministic_noise = (x,p,t) -> 0.5sin(16.1t),\n           noise_param = nothing,\n           tspan = (0.0, 72.9),\n           adapt_gain = 3.35)","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"(Image: )","category":"page"},{"location":"examples/adaptive_control/#","page":"Model Reference Adaptive Control","title":"Model Reference Adaptive Control","text":"Yikes! It looks like that parameter drift can lead to system instability. We won't go into the strategies to mitigate this problem here, but if you're interested, check out Slotine and Li's Applied Nonlinear Control.","category":"page"},{"location":"quickstart/#Quick-Start-1","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/#General-use-1","page":"Quick Start","title":"General use","text":"","category":"section"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"The easiest way to construct 1-dimensional ComponentArrays is as if they were NamedTuples. In fact, a good way to think about them is as arbitrarily nested, mutable NamedTuples that can be passed through a solver.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> c = (a=2, b=[1, 2]);\n  \njulia> x = ComponentArray(a=1.0, b=[2, 1, 4], c=c)\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 2.0, b = [1.0, 2.0]))\n  \njulia> x.c.a = 400; x\nComponentVector{Float64}(a = 1.0, b = [2.0, 1.0, 4.0], c = (a = 400.0, b = [1.0, 2.0]))\n  \njulia> x[5]\n400.0\n  \njulia> collect(x)\n7-element Array{Float64,1}:\n   1.0\n   2.0\n   1.0\n   4.0\n 400.0\n   1.0\n   2.0\n\njulia> typeof(similar(x, Int32)) === typeof(ComponentVector{Int32}(a=1, b=[2, 1, 4], c=c))\ntrue","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"Higher dimensional ComponentArrays can be created too, but it's a little messy at the moment. The nice thing for modeling is that dimension expansion through broadcasted operations can create higher-dimensional ComponentArrays automatically, so Jacobian cache arrays that are created internally with false .* x .* x' will be ComponentArrays with proper axes. Check out the ODE with Jacobian example in the examples folder to see how this looks in practice.","category":"page"},{"location":"quickstart/#","page":"Quick Start","title":"Quick Start","text":"julia> x2 = x .* x'\n7×7 ComponentArray{Tuple{Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))},Axis{(a = 1, b = 2:4, c = (5:7, (a = 1, b = 2:3)))}},Float64,2,Array{Float64,2}}:\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 4.0  8.0  4.0  16.0  8.0  4.0  8.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n 1.0  2.0  1.0   4.0  2.0  1.0  2.0\n 2.0  4.0  2.0   8.0  4.0  2.0  4.0\n \njulia> x2[:c,:c]\n3×3 ComponentArray{Tuple{Axis{(a = 1, b = 2:3)},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 4.0  2.0  4.0\n \njulia> x2[:a,:a]\n 1.0\n \njulia> x2[:a,:c]\nComponentArray{Float64}(a = 2.0, b = [1.0, 2.0])\n\njulia> x2[:b,:c]\n3×3 ComponentArray{Tuple{Axis{NamedTuple()},Axis{(a = 1, b = 2:3)}},Float64,2,SubArray{Float64,2,Array{Float64,2},Tuple{UnitRange{Int64},UnitRange{Int64}},false}}:\n 4.0  2.0  4.0\n 2.0  1.0  2.0\n 8.0  4.0  8.0","category":"page"},{"location":"examples/coulomb_control/#Control-of-a-sliding-block-1","page":"Control of a sliding block","title":"Control of a sliding block","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"using ComponentArrays\nusing DifferentialEquations\nusing Interact: @manipulate\nusing Parameters: @unpack\nusing Plots","category":"page"},{"location":"examples/coulomb_control/#Problem-Setup-1","page":"Control of a sliding block","title":"Problem Setup","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const g = 9.80665\n\nmaybe_apply(f::Function, x, p, t) = f(x, p, t)\nmaybe_apply(f, x, p, t) = f\n\n# Applies functions of form f(x,p,t) to be applied and passed in as inputs\nfunction simulator(func; kwargs...)\n    simfun(dx, x, p, t) = func(dx, x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    simfun(x, p, t) = func(x, p, t; map(f->maybe_apply(f, x, p, t), (;kwargs...))...)\n    return simfun\nend\n\nsoftsign(x) = tanh(1e3x)","category":"page"},{"location":"examples/coulomb_control/#Component-Functions-1","page":"Control of a sliding block","title":"Component Functions","text":"","category":"section"},{"location":"examples/coulomb_control/#A-sliding-block-with-two-different-friction-models-1","page":"Control of a sliding block","title":"A sliding block with two different friction models","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"# Sliding block with viscous friction\nfunction viscous_block!(D, vars, p, t; u=0.0)\n    @unpack m, c, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    D.v = (-c*v + k*(u-x))/m\n    return x\nend\n\n# Sliding block with coulomb friction\nfunction coulomb_block!(D, vars, p, t; u=0.0)\n    @unpack m, μ, k = p\n    @unpack v, x = vars\n\n    D.x = v\n    a = -μ*g*softsign(v) + k*(u-x)/m\n    D.v = abs(a)<1e-3 && abs(v)<1e-3 ? -10v : a #deadzone to help the simulation\n    return x\nend","category":"page"},{"location":"examples/coulomb_control/#PID-feedback-control-1","page":"Control of a sliding block","title":"PID feedback control","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"function PID_controller!(D, vars, p, t; err=0.0, v=0.0)\n    @unpack kp, ki, kd = p\n    @unpack x = vars\n\n    D.x = ki*err\n    return x + kp*err + kd*v\nend\n\nfunction feedback_sys!(D, components, p, t; ref=0.0)\n    @unpack ctrl, plant = components\n\n    u = p.ctrl.fun(D.ctrl, ctrl, p.ctrl.params, t; err=ref-plant.x, v=-plant.v)\n    return p.plant.fun(D.plant, plant, p.plant.params, t; u=u)\nend\n\nstep_input(;time=1.0, mag=1.0) = (x,p,t) -> t>time ? mag : 0\nsine_input(;mag=1.0, period=10.0) = (x,p,t) -> mag*sin(t*2π/period)\n\n# Equivalent viscous damping coefficient taken from:\n# https://engineering.purdue.edu/~deadams/ME563/lecture2010.pdf\nvisc_equiv(μ, N, ω, mag) = 4*μ*N/(π*ω*mag)","category":"page"},{"location":"examples/coulomb_control/#Open-Loop-Response-1","page":"Control of a sliding block","title":"Open-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"To see the open-loop response of the coulomb system, let's set the input to 5 and plot the results. ","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"const tspan = (0.0, 30.0)\nconst m = 50.0\nconst μ = 0.1\nconst k = 50.0\n\np = (m=m, μ=μ, k=k)\nic = ComponentArray(v=0, x=0)\n\nODEProblem(simulator(coulomb_block!, u=5), ic, tspan, p) |> solve |> plot","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/coulomb_control/#Closed-Loop-Response-1","page":"Control of a sliding block","title":"Closed-Loop Response","text":"","category":"section"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"For the closed-loop response, let's make an interactive GUI. Since we are using ComponentArrays, we don't have to change anything about our plant model to incorporate it in the overall system simulation.","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"p = (\n    ctrl = (\n        params = (kp=13, ki=12, kd=5),\n        fun = PID_controller!,\n    ),\n    plant = (\n        params = plant_p,\n        fun = coulomb_block!,\n    ),\n)\n\nic = ComponentArray(ctrl=(;x=0), plant=plant_ic)\n\nsol = ODEProblem(simulator(feedback_sys!, ref=10), ic, tspan, p) |> solve\nplot(sol, vars=3)","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"## Interactive GUI for switching out plant models and varying PID gains\n@manipulate for kp in 0:0.01:15,\n                ki in 0:0.01:15, \n                kd in 0:0.01:15,\n                damping in Dict(\n                    \"Coulomb\" => coulomb_block!,\n                    \"Viscous\" => viscous_block!,\n                ),\n                reference in Dict(\n                    \"Sine\" => sine_input,\n                    \"Step\" => step_input,\n                ),\n                magnitude in 0:0.01:10, # pop-pop!\n                period in 1:0.01:30,\n                plot_v in false\n    \n    # Inputs\n    tspan = (0.0, 30.0)\n\n    ctrl_fun = PID_controller!\n    # plant_fun = coulomb_block!\n    \n    ref = if reference==sine_input\n        reference(period=period, mag=magnitude)\n        else\n        reference(mag=magnitude)\n    end\n    \n    m = 50.0\n    μ = 0.1\n    ω = 2π/period\n    c = 4*μ*m*g/(π*ω*magnitude) # Viscous equivalent damping\n    k = 50.0\n\n    plant_p = (m=m, μ=μ, c=c, k=k) # We'll just put everything for both models in here\n    ctrl_p = (kp=kp, ki=ki, kd=kd)\n\n    plant_ic = (v=0, x=0)\n    ctrl_ic = (;x=0)\n\n\n\n    # Set up and solve\n    sys_p = (\n        ctrl = (\n            params = ctrl_p,\n            fun = ctrl_fun,\n        ),\n        plant = (\n            params = plant_p,\n            fun = damping,\n        ),\n    )\n    sys_ic = ComponentArray(ctrl=ctrl_ic, plant=plant_ic)\n    sys_fun = ODEFunction(simulator(feedback_sys!, ref=ref), syms=[:u, :v, :x])\n    sys_prob = ODEProblem(sys_fun, sys_ic, tspan, sys_p)\n\n    sol = solve(sys_prob, Tsit5())\n\n\n    # Plot\n    t = tspan[1]:0.1:tspan[2]\n    lims = magnitude*[-1, 1]\n    plotvars = plot_v ? [3, 2] : [3]\n    strip = plot(t, ref.(0, 0, t), ylim=1.2lims, label=\"r(t)\")\n    plot!(strip, sol, vars=plotvars)\n    phase = plot(ref.(0, 0, t), map(x->x.plant.x, sol(t).u),\n        xlim=lims,\n        ylim=1.2lims,\n        legend=false,\n        xlabel=\"r(t)\",\n        ylabel=\"x(t)\",\n    )\n    plot(strip, phase, layout=(2, 1), size=(700, 800))\n\nend","category":"page"},{"location":"examples/coulomb_control/#","page":"Control of a sliding block","title":"Control of a sliding block","text":"(Image: )","category":"page"},{"location":"examples/DiffEqFlux/#Neural-ODEs-with-DiffEqFlux-1","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"","category":"section"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Let's see how easy it is to make dense neural ODE layers from scratch. Flux is used here just for the glorot_uniform function and the ADAM optimizer.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"This example is taken from the DiffEqFlux documentation. ","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"using ComponentArrays\nusing OrdinaryDiffEq\nusing Plots\nusing UnPack\n\nusing DiffEqFlux: sciml_train\nusing Flux: glorot_uniform, ADAM\nusing Optim: LBFGS","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"First, let's set up the problem and create the truth data.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"u0 = Float32[2.; 0.]\ndatasize = 30\ntspan = (0.0f0, 1.5f0)\n\nfunction trueODEfunc(du, u, p, t)\n    true_A = [-0.1 2.0; -2.0 -0.1]\n    du .= ((u.^3)'true_A)'\nend\n\nt = range(tspan[1], tspan[2], length = datasize)\nprob = ODEProblem(trueODEfunc, u0, tspan)\node_data = Array(solve(prob, Tsit5(), saveat = t))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Next we'll make a function that creates dense neural layer components. It is similar to Flux.Dense, except it doesn't handle the activation function. We'll do that separately.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"dense_layer(in, out) = ComponentArray{Float32}(W=glorot_uniform(out, in), b=zeros(out))","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Our parameter vector will be a ComponentArray that holds the ODE initial conditions and the dense neural layers.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"layers = (L1=dense_layer(2, 50), L2=dense_layer(50, 2))\nθ = ComponentArray(u=u0, p=layers)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"We now have convenient struct-like access to the weights and biases of the layers for our neural ODE function while giving our optimizer something that acts like a flat array.","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"function dudt(u, p, t)\n    @unpack L1, L2 = p\n    return L2.W * tanh.(L1.W * u.^3 .+ L1.b) .+ L2.b\nend\n\nprob = ODEProblem(dudt, u0, tspan)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"predict_n_ode(θ) = Array(solve(prob, Tsit5(), u0=θ.u, p=θ.p, saveat=t))\n\nfunction loss_n_ode(θ)\n    pred = predict_n_ode(θ)\n    loss = sum(abs2, ode_data .- pred)\n    return loss, pred\nend\nloss_n_ode(θ)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"Let's set up a training observation callback and train!","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"cb = function (θ, loss, pred; doplot=false)\n    display(loss)\n    # plot current prediction against data\n    pl = scatter(t, ode_data[1,:], label = \"data\")\n    scatter!(pl, t, pred[1,:], label = \"prediction\")\n    display(plot(pl))\n    return false\nend\ncb(θ, loss_n_ode(θ)...)\n\ndata = Iterators.repeated((), 1000)\n\nres1 = sciml_train(loss_n_ode, θ, ADAM(0.05); cb=cb, maxiters=100)\ncb(res1.minimizer, loss_n_ode(res1.minimizer)...; doplot=true)\n\nres2 = sciml_train(loss_n_ode, res1.minimizer, LBFGS(); cb=cb)\ncb(res2.minimizer, loss_n_ode(res2.minimizer)...; doplot=true)","category":"page"},{"location":"examples/DiffEqFlux/#","page":"Neural ODEs with DiffEqFlux","title":"Neural ODEs with DiffEqFlux","text":"(Image: )","category":"page"},{"location":"examples/ODE_jac/#ODE-with-Jacobian-1","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"","category":"section"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"This example shows how to use ComponentArrays for composing Jacobian update functions as well as ODE functions. Note using plain symbols to index into ComponentArrays is still pretty slow. Until symbolic indexing is faster, the convenience function fastindices can be used to speed up simulation. The general syntax looks like","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"_x, _y, _z = fastindices(:x, :y, :z)\nD[_x,_y] = σ","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"For more information on fastindices, see its entry in the API section.","category":"page"},{"location":"examples/ODE_jac/#","page":"ODE with Jacobian","title":"ODE with Jacobian","text":"using ComponentArrays\nusing DifferentialEquations\nusing Parameters: @unpack\n\n\ntspan = (0.0, 20.0)\n\n\n## Lorenz system\nfunction lorenz!(D, u, p, t; f=0.0)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D.x = σ*(y - x)\n    D.y = x*(ρ - z) - y - f\n    D.z = x*y - β*z\n    return nothing\nend\nfunction lorenz_jac!(D, u, p, t)\n    @unpack σ, ρ, β = p\n    @unpack x, y, z = u\n    \n    D[:x,:x] = -σ\n    D[:x,:y] = σ\n\n    D[:y,:x] = ρ\n    D[:y,:y] = -1\n    D[:y,:z] = -x\n\n    D[:z,:x] = y\n    D[:z,:y] = x\n    D[:z,:z] = -β\n    return nothing\nend\n\nlorenz_p = (σ=10.0, ρ=28.0, β=8/3)\nlorenz_ic = ComponentArray(x=0.0, y=0.0, z=0.0)\nlorenz_fun = ODEFunction(lorenz!, jac=lorenz_jac!)\nlorenz_prob = ODEProblem(lorenz_fun, lorenz_ic, tspan, lorenz_p)\n\n\n## Lotka-Volterra system\nfunction lotka!(D, u, p, t; f=0.0)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D.x =  α*x - β*x*y + f\n    D.y = -γ*y + δ*x*y\n    return nothing\nend\nfunction lotka_jac!(D, u, p, t)\n    @unpack α, β, γ, δ = p\n    @unpack x, y = u\n    \n    D[:x,:x] = α - β*y\n    D[:x,:y] = -β*x\n\n    D[:y,:x] = δ*y\n    D[:y,:y] = -γ + δ*x\n    return nothing\nend\n\nlotka_p = (α=2/3, β=4/3, γ=1.0, δ=1.0)\nlotka_ic = ComponentArray(x=1.0, y=1.0)\nlotka_fun = ODEFunction(lotka!, jac=lotka_jac!)\nlotka_prob = ODEProblem(lotka_fun, lotka_ic, tspan, lotka_p)\n\n\n## Composed Lorenz and Lotka-Volterra system\nfunction composed!(D, u, p, t)\n    c = p.c #coupling parameter\n    @unpack lorenz, lotka = u\n    \n    lorenz!(D.lorenz, lorenz, p.lorenz, t, f=c*lotka.x)\n    lotka!(D.lotka, lotka, p.lotka, t, f=c*lorenz.x)\n    return nothing\nend\nfunction composed_jac!(D, u, p, t)\n    c = p.c\n    @unpack lorenz, lotka = u\n    \n    lorenz_jac!(D[:lorenz,:lorenz], lorenz, p.lorenz, t)\n    lotka_jac!(D[:lotka,:lotka], lotka, p.lotka, t)\n\n    D[:lorenz,:lotka][:y,:x] = -c\n    D[:lotka,:lorenz][:x,:x] = c\n    return nothing\nend\n\ncomp_p = (lorenz=lorenz_p, lotka=lotka_p, c=0.01)\ncomp_ic = ComponentArray(lorenz=lorenz_ic, lotka=lotka_ic)\ncomp_fun = ODEFunction(composed!, jac=composed_jac!)\ncomp_prob = ODEProblem(comp_fun, comp_ic, tspan, comp_p)\n\n\n## Solve problem\n# We can solve the composed system...\ncomp_sol = solve(comp_prob, Rodas5())\n\n# ...or we can unit test one of the component systems\nlotka_sol = solve(lotka_prob, Rodas5())","category":"page"},{"location":"#ComponentArrays.jl-1","page":"Home","title":"ComponentArrays.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The main export of this package is the ComponentArray type. \"Components\" of ComponentArrays are really just array blocks that can be accessed through a named index. The magic here is that this named indexing can create a new ComponentArray whose data is a view into the original, allowing for standalone models to be composed together by simple function composition. In essence, ComponentArrays allow you to do the things you would usually need a modeling language for, but without actually needing a modeling language. The main targets are for use in DifferentialEquations.jl and Optim.jl, but anything that requires flat vectors is fair game.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"examples/example1.md\"]\nDepth = 2","category":"page"}]
}
